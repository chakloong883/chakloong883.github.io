---
title: '目标检测网络横向对比'
# date: 2199-01-01
# permalink: /posts/2012/08/blog-post-4/
tags:
  - object detection
---
<table class="jop-noMdConv"><thead class="jop-noMdConv"><tr class="jop-noMdConv"><th class="jop-noMdConv"></th><th class="jop-noMdConv">SSD</th><th class="jop-noMdConv">YOLOv3</th><th class="jop-noMdConv">YOLOv4</th><th class="jop-noMdConv">YOLOv5</th><th class="jop-noMdConv">YOLOv6</th><th class="jop-noMdConv">YOLOv7</th><th class="jop-noMdConv">YOLOV8</th></tr></thead><tbody class="jop-noMdConv"><tr class="jop-noMdConv"><td class="jop-noMdConv">相关介绍</td><td class="jop-noMdConv"><a title="http://t.csdnimg.cn/1lC5E" href="http://t.csdnimg.cn/1lC5E" class="jop-noMdConv">http://t.csdnimg.cn/1lC5E</a></td><td class="jop-noMdConv"><a title="http://t.csdnimg.cn/v8HjQ" href="http://t.csdnimg.cn/v8HjQ" class="jop-noMdConv">http://t.csdnimg.cn/v8HjQ</a></td><td class="jop-noMdConv"><a title="http://t.csdnimg.cn/q2yOO" href="http://t.csdnimg.cn/q2yOO" class="jop-noMdConv">http://t.csdnimg.cn/q2yOO</a></td><td class="jop-noMdConv"><a title="https://docs.ultralytics.com/zh/yolov5/tutorials/architecture_description/" href="https://docs.ultralytics.com/zh/yolov5/tutorials/architecture_description/" class="jop-noMdConv">https://docs.ultralytics.com/zh/yolov5/</a><br class="jop-noMdConv"><a title="https://docs.ultralytics.com/zh/yolov5/tutorials/architecture_description/" href="https://docs.ultralytics.com/zh/yolov5/tutorials/architecture_description/" class="jop-noMdConv">tutorials/architecture_description/</a><br class="jop-noMdConv"><a title="http://t.csdnimg.cn/gaYjL" href="http://t.csdnimg.cn/gaYjL" class="jop-noMdConv">http://t.csdnimg.cn/gaYjL</a></td><td class="jop-noMdConv"><a title="https://tech.meituan.com/2022/06/23/yolov6-a-fast-and-accurate-target-detection-framework-is-opening-source.html" href="https://tech.meituan.com/2022/06/23/yolov6-a-fast-and-accurate-target-detection-framework-is-opening-source.html" class="jop-noMdConv">https://tech.meituan.com/2022/06/23/yolov6-a-fast-and-accurate-target-detection-framework-is-opening-source.html</a></td><td class="jop-noMdConv"><a title="http://t.csdnimg.cn/Bw5Ki" href="http://t.csdnimg.cn/Bw5Ki" class="jop-noMdConv">http://t.csdnimg.cn/Bw5Ki</a></td><td class="jop-noMdConv"><a title="http://t.csdnimg.cn/8k7S3" href="http://t.csdnimg.cn/8k7S3" class="jop-noMdConv">http://t.csdnimg.cn/8k7S3</a></td></tr><tr class="jop-noMdConv"><td class="jop-noMdConv">骨干网络</td><td class="jop-noMdConv">VGG</td><td class="jop-noMdConv">darknet53</td><td class="jop-noMdConv">CSPDarkNet53，使用了Mish激活函数</td><td class="jop-noMdConv">New CSP-Darknet53,使用了SILU激活函数</td><td class="jop-noMdConv">EffificientRep，来源于RepVGG<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">RepVGG是一种在训练时具有多分支拓扑，而在实际部署时可以等效融合为单个 3x3 卷积的一种可重参数化的结构，详细介绍：<a data-resource-id="5110acf0a47d459e8f56e24c5292a0bc" href="joplin://5110acf0a47d459e8f56e24c5292a0bc" class="jop-noMdConv">YOLOV6</a></li></ul></td><td class="jop-noMdConv">主干使用了多分支堆叠模块<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">Multi_Concat_Block模块更加密集 <a title="https://img-blog.csdnimg.cn/33fd8b058480428fbb5f0c0589dcc4bc.png#pic_center" href="https://img-blog.csdnimg.cn/33fd8b058480428fbb5f0c0589dcc4bc.png#pic_center" class="jop-noMdConv">https://img-blog.csdnimg.cn/33fd8b058480428fbb5f0c0589dcc4bc.png#pic_center</a></li><li class="jop-noMdConv">使用了Transition_Block进行下采样，有两个分支，结合了最大池化和卷积核分开下采样后concat <a title="https://img-blog.csdnimg.cn/27fcffca436e4681b9d764d2d4eff9df.png#pic_center" href="https://img-blog.csdnimg.cn/27fcffca436e4681b9d764d2d4eff9df.png#pic_center" class="jop-noMdConv">https://img-blog.csdnimg.cn/27fcffca436e4681b9d764d2d4eff9df.png#pic_center</a></li></ul></td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">第一次卷积的卷积核变小了，是3不是6</li><li class="jop-noMdConv">CSP模块用到了通道分割，bottleneck， 多堆叠结构</li></ul></td></tr><tr class="jop-noMdConv"><td class="jop-noMdConv">特征层处理</td><td class="jop-noMdConv">选取6个特征层用作处理</td><td class="jop-noMdConv">3个特征层(13、26、52)</td><td class="jop-noMdConv">3个特征层(19、38、76)</td><td class="jop-noMdConv">3个特征层(20、40、80)</td><td class="jop-noMdConv">3个特征层(20、40、80)</td><td class="jop-noMdConv">3个特征层(20、40、80)</td><td class="jop-noMdConv">3个特征层(20、40、80)</td></tr><tr class="jop-noMdConv"><td class="jop-noMdConv">FPN网络</td><td class="jop-noMdConv">没有FPN网络</td><td class="jop-noMdConv">5次上采样进行concat</td><td class="jop-noMdConv">SPP、PANet，<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">SPP用(5、9、13大小的最大池化层对最小的特征处理，极大地增大感受野)</li><li class="jop-noMdConv">PANet,特征层的反复提取，除了上采样还有下采样融合过程</li></ul></td><td class="jop-noMdConv">SPPF、New CSP-PAN<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">相比SPP，SPPF用5x5大小的池化核进行三次池化，每一次池化的特征层存下来，最后再concat一起</li><li class="jop-noMdConv">New CSP-PAN使用了CSP残差模块</li></ul></td><td class="jop-noMdConv">SimSPPF、Rep=PAN<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">用RepBlock替换了YOLOv5中使用的CSP-Block</li></ul></td><td class="jop-noMdConv">SPPCSCP、<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">具有CSP机构的SPP扩大感受野,该模块具有一个大的残差边辅助优化与特征提取。</li><li class="jop-noMdConv">与YOLOv4的PANet结构相似，该FPN含有Transition_Block模块</li></ul></td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">SPPF模块同YOLOv5</li><li class="jop-noMdConv">PANet模块类似YOLOv5，但不再对提取的特征层卷积(省计算量加快速度)，CSP模块与主干相同，用到了通道分割</li></ul></td></tr><tr class="jop-noMdConv"><td class="jop-noMdConv">是否有锚框</td><td class="jop-noMdConv">不同特征层每个网格设置4个或6个先验框与之对应</td><td class="jop-noMdConv">每个网格有3个anchor</td><td class="jop-noMdConv">每个网格有3个anchor</td><td class="jop-noMdConv">每个网格有3个anchor</td><td class="jop-noMdConv">无锚框，point-base</td><td class="jop-noMdConv">每个网格有3个anchor</td><td class="jop-noMdConv">无锚框，每个特征点预测的是距离特征点左上和右下的距离</td></tr><tr class="jop-noMdConv"><td class="jop-noMdConv">检测头</td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">位置:num_anchors x 4</li><li class="jop-noMdConv">类别:num_anchors x num_classes</li></ul></td><td class="jop-noMdConv">num_anchors x (5+num_classes)</td><td class="jop-noMdConv">num_anchors x (5+num_classes)</td><td class="jop-noMdConv">num_anchors x (5+num_classes)</td><td class="jop-noMdConv">检测头将位置、类别、有无物体进行解耦<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">类别检测头</li><li class="jop-noMdConv">位置检测头</li><li class="jop-noMdConv">有无物体检测头</li></ul></td><td class="jop-noMdConv">num_anchors x (5+num_classes)</td><td class="jop-noMdConv">解耦头，将位置、类别进行解耦<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">位置检测头，使用了DFL，将回归问题转换成分类问题，以概率的形式获得回归值，4个回归值长度为16，每个特征层通道数为64，如(20,20,64)</li><li class="jop-noMdConv">种类预测头，通道数为种类数，如种类数是20，则每个特征层的通道数是20，如（20，20，20）</li></ul></td></tr><tr class="jop-noMdConv"><td class="jop-noMdConv">如何分配标签</td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">每个真实框与所有的先验框的iou，根据重合情况是否大于阈值决定是否是正样本</li><li class="jop-noMdConv">- 从正样本中找到每个与之最匹配的真实框(iou最大)，按照这个真实框进行匹配</li></ul></td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">每个真实框与所有的先验框的iou，与真实框iou最高的先验框为正样本</li><li class="jop-noMdConv">在上一点基础上，计算解码后的anchor与真实框的iou，大于一定阈值(0.7)，从负样本中剔除</li></ul></td><td class="jop-noMdConv">同YOLOv3</td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">计算真实框与9个先验框的纵横比，如果在设定一定比率范围内则认定为正样本</li><li class="jop-noMdConv">找到先验框后，根据真实框的中心点找网格点，其2个最近的邻域网格也被选中，给这三个网格的符合比率的anchor分配为正样本，此时中心点的偏移范围从(0,1)变成(-0.5,1.5)</li><li class="jop-noMdConv">在上一点基础上，计算解码后的anchor与真实框的iou，大于一定阈值(0.7)，从负样本中剔除</li></ul></td><td class="jop-noMdConv"><strong class="jop-noMdConv">simOTA</strong> <a title="http://t.csdnimg.cn/SFDqI" href="http://t.csdnimg.cn/SFDqI" class="jop-noMdConv">http://t.csdnimg.cn/SFDqI</a><br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">提取真实框与预测框的重合程度、种类预测准确度、中心是否落在特征点半径，根据这些信息构造cost矩阵</li><li class="jop-noMdConv">计算每个目标cost最低的10个特征点</li><li class="jop-noMdConv">把这10个特征点预测的预测框与真实框进行IOU操作，则会得到10个IOU的值</li><li class="jop-noMdConv">将10个IOU的值进行sum操作后会得到一个值，此时的值为dynamic_k</li><li class="jop-noMdConv">根据cost矩阵挑出前k个候选框，并去除重复候选框<br class="jop-noMdConv"><strong class="jop-noMdConv">TAL</strong></li><li class="jop-noMdConv">针对所有像素点预测的 Cls score 和 Reg Score(Box与每个GT box的IOU) ,通过加权的方式得到最终的加权分数，通过对加权分数进行排序后选择Topk个正样本(bbox)</li><li class="jop-noMdConv">选取bbox所使用anchor的中心落在gt内的为正样本</li><li class="jop-noMdConv">若一个anchor box对应多个gt，则选择gt与预测框IoU最大那个预测框对应anchor负责该gt</li></ul></td><td class="jop-noMdConv">初步筛选同YOLOv5的1、2点，进一步筛选使用了simOTA<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">计算每个真实框和当前特征点预测框的重合程度</li><li class="jop-noMdConv">计算将重合度最高的二十个预测框与真实框的IOU加起来求得每个真实框的k，也就代表每个真实框有k个特征点与之对应</li><li class="jop-noMdConv">计算每个真实框和当前特征点预测框的种类预测准确度</li><li class="jop-noMdConv">计算Cost代价矩阵</li><li class="jop-noMdConv">将Cost最低的k个点作为该真实框的正样本</li></ul></td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">找到位于真实框内部的特征点</li><li class="jop-noMdConv">计算这些特征点的预测框与真实框的重合程度、种类的准确度，计算Cost代价矩阵</li><li class="jop-noMdConv">与simOTA不同，YOLOv8的k值是定值(最大13), 将Cost最低的k个点作为该真实框的正样本</li><li class="jop-noMdConv">若上面筛选的anchor对应多个gt，则选择gt与预测框IoU最大那个预测框对应anchor负责该gt</li></ul></td></tr><tr class="jop-noMdConv"><td class="jop-noMdConv">边界框回归损失</td><td class="jop-noMdConv">smoothL1 回归损失</td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">正样本中心偏移情况的loss，使用BCELoss</li><li class="jop-noMdConv">正样本宽高调整值的loss用MSE</li></ul></td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">正样本的边界框回归用CIOULoss</li></ul></td><td class="jop-noMdConv">同YOLOv4</td><td class="jop-noMdConv">SIoU 边界框回归损失</td><td class="jop-noMdConv">CIOULoss</td><td class="jop-noMdConv">由于使用了DFL，使用交叉熵损失和iou损失，iou损失占的比重大， dfl损失占的比重小</td></tr><tr class="jop-noMdConv"><td class="jop-noMdConv">分类损失</td><td class="jop-noMdConv">含有背景类别(0)<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">正样本的交叉熵</li><li class="jop-noMdConv">负样本的交叉熵</li></ul></td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">正样本类别的交叉熵</li></ul></td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">正样本类别的交叉熵，类别标签可使用smoothlabels</li></ul></td><td class="jop-noMdConv">同YOLOv4</td><td class="jop-noMdConv">同YOLO5</td><td class="jop-noMdConv">同YOLO5</td><td class="jop-noMdConv">同YOLOv5，使用交叉熵，但是标签是预测框和真实框的重合程度*真实类别</td></tr><tr class="jop-noMdConv"><td class="jop-noMdConv">损失函数</td><td class="jop-noMdConv">分类损失+边界框回归损失</td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">边界框回归损失</li><li class="jop-noMdConv">分类损失</li><li class="jop-noMdConv">置信度损失：正样本中预测结果中置信度的值与1对比的交叉熵+负样本中预测结果中置信度的值与0对比的交叉熵</li><li class="jop-noMdConv">以上全部相加</li></ul></td><td class="jop-noMdConv">同YOLOv3</td><td class="jop-noMdConv">同YOLOv4</td><td class="jop-noMdConv"><a title="https://zhuanlan.zhihu.com/p/572443911" href="https://zhuanlan.zhihu.com/p/572443911" class="jop-noMdConv">https://zhuanlan.zhihu.com/p/572443911</a><br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">回归损失(iou和l1)</li><li class="jop-noMdConv">分类损失(交叉熵)</li><li class="jop-noMdConv">置信度损失(交叉熵)</li><li class="jop-noMdConv">以上全部相加</li></ul></td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">边界框回归损失</li><li class="jop-noMdConv">分类损失</li><li class="jop-noMdConv">置信度损失：正样本中预测结果中置信度的值与1对比的交叉熵+负样本中预测结果中置信度的值与0对比的交叉熵</li><li class="jop-noMdConv">以上全部相加</li></ul></td><td class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">边界框损失DFL</li><li class="jop-noMdConv">边界框IOU损失</li><li class="jop-noMdConv">类别损失</li><li class="jop-noMdConv">7.5 * 边界框IOU损失 + 0.5 * 类别损失 + 1.5 * DFL交叉熵损失</li></ul></td></tr><tr class="jop-noMdConv"><td class="jop-noMdConv">正负样本处理策略</td><td class="jop-noMdConv">取三倍正样本数量的负样本用于训练</td><td class="jop-noMdConv">参考分配标签策略，此方法能筛掉很大部分的负样本</td><td class="jop-noMdConv">同YOLOv3</td><td class="jop-noMdConv">参考分配标签策略</td><td class="jop-noMdConv">参考分配标签策略</td><td class="jop-noMdConv">参考分配标签策略</td><td class="jop-noMdConv">参考分配标签策略</td></tr><tr class="jop-noMdConv"><td class="jop-noMdConv">后处理</td><td class="jop-noMdConv">nms</td><td class="jop-noMdConv">nms</td><td class="jop-noMdConv">nms</td><td class="jop-noMdConv">nms</td><td class="jop-noMdConv">nms</td><td class="jop-noMdConv">nms</td><td class="jop-noMdConv">nms</td></tr><tr class="jop-noMdConv"><td class="jop-noMdConv">缺陷或不足</td><td class="jop-noMdConv"></td><td class="jop-noMdConv"></td><td class="jop-noMdConv"></td><td class="jop-noMdConv"></td><td class="jop-noMdConv"></td><td class="jop-noMdConv"></td><td class="jop-noMdConv"></td></tr><tr class="jop-noMdConv"><td class="jop-noMdConv">总结</td><td class="jop-noMdConv"></td><td class="jop-noMdConv"></td><td class="jop-noMdConv">相比YOLOv3：<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">改进了骨干网络</li><li class="jop-noMdConv">使用了SPP增大感受野</li><li class="jop-noMdConv">改进了FPN网络</li><li class="jop-noMdConv">使用了Mosaic数据增强</li><li class="jop-noMdConv">使用了labelsmoothing</li><li class="jop-noMdConv">边界框回归使用了CIOULoss</li><li class="jop-noMdConv">使用了余弦退火学习率</li></ul></td><td class="jop-noMdConv">相比YOLOv3：<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">改进了骨干网络</li><li class="jop-noMdConv">改进了SPP，使用SPPF，速度更快，快一倍</li><li class="jop-noMdConv">改进了FPN网络，使用了CSP残差结构</li><li class="jop-noMdConv">改进了Mosaic数据增强，还有附带了复制粘贴、仿射变换、水平翻转等</li><li class="jop-noMdConv">各种训练技巧，如多尺度训练、超参数调优、超参数进化等</li></ul></td><td class="jop-noMdConv">相比于YOLOv5：<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">骨干：EiffenetRep</li><li class="jop-noMdConv">标签分配：simOTA,TAL</li><li class="jop-noMdConv">回归损失：SIOU</li><li class="jop-noMdConv">PAN：Rep-PAN</li><li class="jop-noMdConv">Head：解耦头</li></ul></td><td class="jop-noMdConv">相比于YOLOv5：<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">模型的跳连接结构更加的密集,使用了创新的下采样结构</li><li class="jop-noMdConv">PANet部分更加密集，也是用了创新的下采样结构</li><li class="jop-noMdConv">SPP结构与YOLOv4类似，增加了CSP机构</li><li class="jop-noMdConv">检测头使用了RepConv，推理时将多分支融合成单分支加快推理速度</li><li class="jop-noMdConv">正负样本分配使用了SimOTA</li></ul></td><td class="jop-noMdConv">相比于YOLOv5：<br class="jop-noMdConv"><ul class="jop-noMdConv"><li class="jop-noMdConv">改进了主干网络，CSP结构用到了通道分割，多维堆叠，减少了卷积次数，减少计算量</li><li class="jop-noMdConv">无锚框的设计</li><li class="jop-noMdConv">解耦检测头，其中回归预测使用了DFL</li><li class="jop-noMdConv">正负样本的OTA，与simOTA相似</li></ul></td></tr></tbody></table>